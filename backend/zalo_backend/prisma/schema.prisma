// ============================================================================
// 1. CONFIGURATION
// ============================================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [pgcrypto, uuidOssp(map: "uuid-ossp")]
}

// ============================================================================
// 2. ENUMS (TYPE DEFINITIONS)
// ============================================================================

// --- User & Identity ---
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  DELETED
  @@map("user_status")
}

enum Gender {
  MALE
  FEMALE
  OTHER
  @@map("gender_type")
}

// --- Privacy & Social ---
enum PrivacyLevel {
  EVERYONE
  CONTACTS
  NOBODY
  @@map("privacy_level")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  @@map("friendship_status")
}

// --- Messaging & Group ---
enum ConversationType {
  DIRECT
  GROUP
  @@map("conversation_type")
}

enum MemberRole {
  ADMIN
  MEMBER
  @@map("member_role")
}

enum MemberStatus {
  PENDING // Chờ duyệt
  ACTIVE  // Đã là thành viên
  KICKED  // Bị kick bởi Admin
  LEFT    // Tự rời nhóm
  @@map("member_status")
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  REJECTED
  @@map("join_request_status")
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE    // document
  STICKER // = image (media type)
  SYSTEM // notification
  AUDIO
  @@map("message_type")
}

enum ReceiptStatus {
  SENT      // Server confirmed receipt
  DELIVERED // Reached recipient's device
  SEEN      // User viewed the message
  @@map("receipt_status")
}

// --- Media ---
enum MediaType {
  IMAGE
  VIDEO
  DOCUMENT
  AUDIO
  @@map("media_type")
}

enum MediaProcessingStatus {
  PENDING       // Presigned URL issued, awaiting upload
  UPLOADED      // File in S3 temp/, not confirmed
  CONFIRMED     // Confirmed by client, awaiting processing
  PROCESSING    // Worker picked up job
  READY         // Processing complete, ready to use
  FAILED        // Processing failed after retries
  EXPIRED       // Upload never completed (cleanup)
  @@map("media_processing_status")
}

// --- Device & Security ---
enum DeviceType {
  WEB
  MOBILE
  DESKTOP
  @@map("device_type")
}

enum Platform {
  IOS
  ANDROID
  WEB
  WINDOWS
  MACOS
  LINUX
  @@map("platform")
}

enum TokenRevocationReason {
  MANUAL_LOGOUT
  PASSWORD_CHANGED
  SUSPICIOUS_ACTIVITY
  TOKEN_ROTATION
  ADMIN_ACTION
  @@map("token_revocation_reason")
}

// ============================================================================
// 3. IAM MODULE (USER, AUTH, RBAC)
// ============================================================================

/**
 * Model: User
 * Central entity of the system.
 */
model User {
  id              String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  phoneNumber     String     @unique @map("phone_number") @db.VarChar(20)
  phoneCode       String     @default("+84") @map("phone_country_code") @db.VarChar(5)
  
  // Profile Info
  displayName     String     @map("display_name") @db.VarChar(100)
  avatarUrl       String?    @map("avatar_url")
  bio             String?    @db.Text
  dateOfBirth     DateTime?  @map("date_of_birth") @db.Date
  gender          Gender?
  status          UserStatus @default(ACTIVE)

  // Security & Activity
  passwordHash    String     @map("password_hash")
  passwordVersion Int        @default(1) @map("password_version") // For instant token invalidation
  lastSeenAt      DateTime?  @map("last_seen_at") @db.Timestamptz

  // RBAC (Role Based Access Control)
  roleId          String?    @map("role_id") @db.Uuid 
  role            Role?      @relation(fields: [roleId], references: [id])

  // --- Audit Fields ---
  createdById     String?    @map("created_by") @db.Uuid
  updatedById     String?    @map("updated_by") @db.Uuid
  deletedById     String?    @map("deleted_by") @db.Uuid
  
  createdAt       DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime?  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt       DateTime?  @map("deleted_at") @db.Timestamptz
  
  // --- Relationships ---
  // Auth & Settings
  privacySettings      PrivacySettings?
  devices              UserDevice[]
  tokens               UserToken[]

  // Social Graph
  sentFriendRequests   Friendship[] @relation("User1")
  receivedFriendRequests Friendship[] @relation("User2")
  friendshipInitiator  Friendship[] @relation("Requester")
  
  blocksBlocked        Block[]      @relation("Blocker")
  blocksWasBlocked     Block[]      @relation("Blocked")

  // Messaging & Groups
  conversations        ConversationMember[]
  joinRequests         GroupJoinRequest[]
  reviewedJoinRequests GroupJoinRequest[] @relation("ReviewedRequests")
  
  messagesSent         Message[]
  messagesDeleted      Message[]    @relation("DeletedBy")

  // Media
  uploadedMedia        MediaAttachment[] @relation("UploadedMedia")

  // System Logs
  socketConnections    SocketConnection[]
  presenceLogs         PresenceLog[]

  @@index([phoneNumber])
  @@index([roleId])
  @@map("users")
}

/**
 * Model: UserToken
 * Handles Refresh Tokens for authentication & session management.
 */
model UserToken {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId           String    @map("user_id") @db.Uuid
  
  // Token Storage (Hashed for security)
  refreshTokenHash String    @unique @map("refresh_token_hash") @db.VarChar(64)
  
  // Device Fingerprint
  deviceId         String    @map("device_id") @db.VarChar(255) 
  deviceName       String?   @map("device_name") @db.VarChar(100) 
  deviceType       DeviceType? @map("device_type")
  platform         Platform?
  
  // Security Tracking
  ipAddress        String?   @map("ip_address") @db.VarChar(45) 
  userAgent        String?   @map("user_agent") @db.Text
  
  // Token Lifecycle
  issuedAt         DateTime  @default(now()) @map("issued_at") @db.Timestamptz
  expiresAt        DateTime  @map("expires_at") @db.Timestamptz
  lastUsedAt       DateTime  @default(now()) @map("last_used_at") @db.Timestamptz
  
  // Revocation Logic
  isRevoked        Boolean   @default(false) @map("is_revoked")
  revokedAt        DateTime? @map("revoked_at") @db.Timestamptz
  revokedReason    TokenRevocationReason? @map("revoked_reason")
  
  // Token Family (Rotation Chain)
  parentTokenId    String?   @map("parent_token_id") @db.Uuid
  parentToken      UserToken? @relation("TokenFamily", fields: [parentTokenId], references: [id], onDelete: SetNull)
  childTokens      UserToken[] @relation("TokenFamily")
  
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, deviceId]) 
  @@index([userId, isRevoked])
  @@index([refreshTokenHash])
  @@index([expiresAt])
  @@index([lastUsedAt])
  @@map("user_tokens")
}

/**
 * Model: UserDevice
 * Tracks physical devices for Push Notifications (FCM).
 */
model UserDevice {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId       String   @map("user_id") @db.Uuid
  deviceId     String   @map("device_id") @db.VarChar(255)
  fcmToken     String?  @map("fcm_token")
  platform     String?  @db.VarChar(20)
  lastActiveAt DateTime @default(now()) @map("last_active_at") @db.Timestamptz

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, deviceId])
  @@map("user_devices")
}

/**
 * Model: Role
 * Defines system-level roles (e.g., ADMIN, USER).
 */
model Role {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String   @unique @db.VarChar(50) 
  description String?  @db.VarChar(255)
  
  // Audit
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz
  
  createdById String?  @map("created_by") @db.Uuid
  updatedById String?  @map("updated_by") @db.Uuid
  deletedById String?  @map("deleted_by") @db.Uuid
  
  users           User[]
  rolePermissions RolePermission[]

  @@map("roles")
}

/**
 * Model: Permission
 * Granular permissions mapped to API paths or modules.
 */
model Permission {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String   @unique @db.VarChar(100) 
  apiPath     String   @map("api_path") 
  method      String   @db.VarChar(10)  
  module      String   @db.VarChar(50)  
  
  // Audit
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz
  
  createdById String?  @map("created_by") @db.Uuid
  updatedById String?  @map("updated_by") @db.Uuid
  deletedById String?  @map("deleted_by") @db.Uuid
  
  roles       RolePermission[]

  @@unique([apiPath, method, module])
  @@map("permissions")
}

/**
 * Model: RolePermission
 * Pivot table for Many-to-Many relation between Roles and Permissions.
 */
model RolePermission {
  roleId       String @map("role_id") @db.Uuid
  permissionId String @map("permission_id") @db.Uuid
  
  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@map("role_permissions")
}

/**
 * Model: PrivacySettings
 * User preferences for privacy.
 */
model PrivacySettings {
  userId           String       @id @map("user_id") @db.Uuid
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  showOnlineStatus PrivacyLevel @default(CONTACTS) @map("show_online_status")
  showPhoneNumber  PrivacyLevel @default(CONTACTS) @map("show_phone_number")
  whoCanMessageMe  PrivacyLevel @default(EVERYONE) @map("who_can_message_me")
  whoCanCallMe     PrivacyLevel @default(CONTACTS) @map("who_can_call_me")

  updatedById      String?      @map("updated_by") @db.Uuid
  updatedAt        DateTime     @default(now()) @updatedAt @map("updated_at") @db.Timestamptz

  @@map("privacy_settings")
}

// ============================================================================
// 4. SOCIAL GRAPH MODULE
// ============================================================================

/**
 * Model: Friendship
 * Manages friend requests and relationships.
 */
model Friendship {
  id          String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user1Id     String           @map("user1_id") @db.Uuid
  user2Id     String           @map("user2_id") @db.Uuid
  requesterId String           @map("requester_id") @db.Uuid
  status      FriendshipStatus @default(PENDING)
  
  // Audit
  updatedById String?          @map("updated_by") @db.Uuid
  deletedById String?          @map("deleted_by") @db.Uuid

  createdAt   DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime         @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt   DateTime?        @map("deleted_at") @db.Timestamptz
  
  user1       User             @relation("User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2       User             @relation("User2", fields: [user2Id], references: [id], onDelete: Cascade)
  requester   User             @relation("Requester", fields: [requesterId], references: [id])

  @@unique([user1Id, user2Id])
  @@index([user1Id, status])
  @@index([user2Id, status])
  @@map("friendships")
}

/**
 * Model: Block
 * Users blocking other users.
 */
model Block {
  id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  blockerId String   @map("blocker_id") @db.Uuid
  blockedId String   @map("blocked_id") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  blocker   User     @relation("Blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("blocks")
}

// ============================================================================
// 5. MESSAGING MODULE
// ============================================================================

/**
 * Model: Conversation
 * Represents a chat room (Direct or Group).
 */
model Conversation {
  id              String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type            ConversationType
  name            String?           @db.VarChar(255)
  avatarUrl       String?           @map("avatar_url")
  lastMessageAt   DateTime?         @map("last_message_at") @db.Timestamptz

  // Group specific settings
  requireApproval Boolean           @default(false) @map("require_approval")
  settings        Json              @default("{}") @db.JsonB
  
  // Audit
  createdById     String?           @map("created_by") @db.Uuid
  updatedById     String?           @map("updated_by") @db.Uuid
  deletedById     String?           @map("deleted_by") @db.Uuid
  
  createdAt       DateTime          @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime          @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt       DateTime?         @map("deleted_at") @db.Timestamptz

  members         ConversationMember[]
  messages        Message[]
  joinRequests    GroupJoinRequest[]

  @@index([lastMessageAt(sort: Desc)])
  @@map("conversations")
}

/**
 * Model: ConversationMember
 * Link user to a conversation with roles and status.
 */
model ConversationMember {
  conversationId    String       @map("conversation_id") @db.Uuid
  userId            String       @map("user_id") @db.Uuid
  role              MemberRole   @default(MEMBER)
  status            MemberStatus @default(ACTIVE) @map("status")

  // Read status tracking
  lastReadMessageId String?      @map("last_read_message_id") @db.Uuid
  lastReadAt        DateTime?    @map("last_read_at") @db.Timestamptz
  unreadCount       Int          @default(0) @map("unread_count")
  
  // Lifecycle
  joinedAt          DateTime     @default(now()) @map("joined_at") @db.Timestamptz
  leftAt            DateTime?    @map("left_at") @db.Timestamptz
  kickedBy          String?      @map("kicked_by") @db.Uuid
  kickedAt          DateTime?    @map("kicked_at") @db.Timestamptz

  conversation      Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([conversationId, userId])
  @@index([userId, status])
  @@index([userId, unreadCount(sort: Desc)])
  // @@unique([conversationId, role], name: "unique_admin_per_group", where: { role: ADMIN, status: ACTIVE })
  @@map("conversation_members")
}

/**
 * Model: GroupJoinRequest
 * Request flow for joining APPROVAL_REQUIRED groups.
 */
model GroupJoinRequest {
  id             String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId String            @map("conversation_id") @db.Uuid
  userId         String            @map("user_id") @db.Uuid
  status         JoinRequestStatus @default(PENDING)
  
  // Metadata
  requestedAt    DateTime          @default(now()) @map("requested_at") @db.Timestamptz
  message        String?           @db.VarChar(500)
  
  // Review tracking
  reviewedBy     String?           @map("reviewed_by") @db.Uuid
  reviewedAt     DateTime?         @map("reviewed_at") @db.Timestamptz
  
  conversation   Conversation      @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer       User?             @relation("ReviewedRequests", fields: [reviewedBy], references: [id])

  @@unique([conversationId, userId])
  @@index([conversationId, status])
  @@index([userId, status])
  @@map("group_join_requests")
}

/**
 * Model: Message
 * Stores individual messages (Core entity).
 */
model Message {
  id              BigInt           @id @default(autoincrement())
  conversationId  String           @map("conversation_id") @db.Uuid
  senderId        String?          @map("sender_id") @db.Uuid
  type            MessageType      @default(TEXT)
  content         String?          @db.Text
  metadata        Json?            @default("{}") @db.JsonB
  
  // Threading / Reply
  replyToId       BigInt?          @map("reply_to_message_id")

  // Idempotency
  clientMessageId String?          @unique @map("client_message_id") @db.VarChar(36)

  // Audit
  updatedById     String?          @map("updated_by") @db.Uuid
  deletedById     String?          @map("deleted_by") @db.Uuid
  
  createdAt       DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime         @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt       DateTime?        @map("deleted_at") @db.Timestamptz

  // Relations
  conversation    Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender          User?            @relation(fields: [senderId], references: [id])
  deletedBy       User?            @relation("DeletedBy", fields: [deletedById], references: [id])
  
  parentMessage   Message?         @relation("Reply", fields: [replyToId], references: [id])
  replies         Message[]        @relation("Reply")
  
  mediaAttachments MediaAttachment[]
  receipts         MessageReceipt[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId, createdAt(sort: Desc)])
  @@index([clientMessageId])
  @@map("messages")
}

/**
 * Model: MessageReceipt
 * Tracks Sent/Delivered/Seen status per user per message.
 */
model MessageReceipt {
  messageId BigInt        @map("message_id")
  userId    String        @map("user_id") @db.Uuid
  status    ReceiptStatus
  timestamp DateTime      @default(now()) @db.Timestamptz
  
  message   Message       @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@id([messageId, userId])
  @@index([userId, status, timestamp])
  @@index([messageId, status])
  @@map("message_receipts")
}

// ============================================================================
// 6. MEDIA MODULE
// ============================================================================

/**
 * Model: MediaAttachment
 * Handles file uploads, S3 storage references, and processing status.
 */
model MediaAttachment {
  id               String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  messageId        BigInt?               @map("message_id") // Nullable before message is sent
  
  // File Metadata
  originalName     String                @map("original_name") @db.VarChar(255)
  mimeType         String                @map("mime_type") @db.VarChar(100)
  mediaType        MediaType             @map("media_type")
  size             BigInt
  
  // S3 Storage
  s3Key            String?                @unique @map("s3_key") @db.VarChar(500)
  s3Bucket         String                @map("s3_bucket") @db.VarChar(100)
  cdnUrl           String?               @map("cdn_url") @db.VarChar(1000)

  // Processed Variants (Thumbnails, etc.)
  thumbnailUrl     String?               @map("thumbnail_url") @db.VarChar(1000)
  thumbnailS3Key   String?               @map("thumbnail_s3_key") @db.VarChar(500)
  duration         Int?                  // Seconds
  width            Int?                  // Pixels
  height           Int?                  // Pixels

  // Processing Workflow
  processingStatus MediaProcessingStatus @default(PENDING) @map("processing_status")
  processingError  String?               @map("processing_error") @db.Text
  processedAt      DateTime?             @map("processed_at") @db.Timestamptz

  //Để hỗ trợ Presigned URL flow
  uploadId         String?               @unique @map("upload_id") @db.VarChar(36)
  s3KeyTemp        String?               @map("s3_key_temp") @db.VarChar(500)
  retryCount       Int                   @default(0) @map("retry_count")

  // Upload Context
  uploadedBy       String                @map("uploaded_by") @db.Uuid
  uploadedFrom     String?               @map("uploaded_from") @db.VarChar(50)
  
  // Audit
  createdAt        DateTime              @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt        DateTime?             @map("deleted_at") @db.Timestamptz
  deletedById      String?               @map("deleted_by") @db.Uuid
  

  message          Message?              @relation(fields: [messageId], references: [id], onDelete: Cascade)
  uploader         User                  @relation("UploadedMedia", fields: [uploadedBy], references: [id])

  @@index([uploadedBy, createdAt(sort: Desc)])
  @@index([processingStatus])
  @@index([s3Key])
  @@index([messageId])
  @@index([createdAt])
  @@index([uploadId])
  @@map("media_attachments")
}

// ============================================================================
// 7. SYSTEM & LOGGING MODULE
// ============================================================================

/**
 * Model: SocketConnection
 * Logs historical socket connections for analytics and debugging.
 */
model SocketConnection {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId           String    @map("user_id") @db.Uuid
  socketId         String    @map("socket_id") @db.VarChar(100)
  
  // Device Context
  deviceId         String    @map("device_id") @db.VarChar(255)
  serverInstance   String?   @map("server_instance") @db.VarChar(50)
  ipAddress        String    @map("ip_address") @db.VarChar(45)
  userAgent        String?   @map("user_agent") @db.Text
  
  // Lifecycle
  connectedAt      DateTime  @default(now()) @map("connected_at") @db.Timestamptz
  disconnectedAt   DateTime? @map("disconnected_at") @db.Timestamptz
  disconnectReason String?   @map("disconnect_reason") @db.VarChar(100)
  
  // Usage Metrics
  messagesSent     Int       @default(0) @map("messages_sent")
  messagesReceived Int       @default(0) @map("messages_received")
  duration         Int?      @map("duration_seconds")
  
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, connectedAt(sort: Desc)])
  @@index([socketId])
  @@index([serverInstance])
  @@index([connectedAt])
  @@map("socket_connections")
}

/**
 * Model: PresenceLog
 * Logs user status changes (Online/Offline/Away).
 */
model PresenceLog {
  id        BigInt   @id @default(autoincrement())
  userId    String   @map("user_id") @db.Uuid
  status    String   @db.VarChar(20)
  deviceId  String?  @map("device_id") @db.VarChar(255)
  timestamp DateTime @default(now()) @db.Timestamptz
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, timestamp(sort: Desc)])
  @@index([timestamp])
  @@map("presence_logs")
}